<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" sizes="any" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <title>MCBAISE • PALE REGARD • ABSURDIA FANTASMAGORIA</title>
  <script>
    // vizOnly iframes should never show the YouTube pane/loading UI.
    // Do this in the head to avoid a flash before the module script runs.
    try {
      const p = new URLSearchParams(location.search);
      if (p.get('vizOnly') === '1') document.documentElement.classList.add('vizOnly');
    } catch (_) {}
  </script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Baloo+2:wght@700;800&display=swap");

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }

    #root { height: 100%; display: flex; }

    /* vizOnly iframes: hide the YouTube pane entirely (no flash). */
    .vizOnly #left { display: none !important; }
    .vizOnly #ytLoading,
    .vizOnly #playerWrap,
    .vizOnly #videoPi { display: none !important; }

    #left, #right {
      flex: 1;
      position: relative;
      min-width: 0;
    }

    #left {
      border-right: 2px solid rgba(255,255,255,0.12);
      background: #000;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* Landscape: hide video by collapsing width. */
    #root.hideVideo #left {
      flex: 0 0 0px;
      width: 0px;
      border-right: 0;
    }

    /* Portrait (more tall than wide): stack vertically (video above, viz below). */
    @media (max-aspect-ratio: 1/1) {
      #root { flex-direction: column; }

      #left {
        border-right: 0;
        border-bottom: 2px solid rgba(255,255,255,0.12);
      }

      /* Give the video a reasonable default height in portrait. */
      #left { flex: 0 0 40%; }
      #right { flex: 1 1 auto; }

      /* Portrait: hide video by collapsing height. */
      #root.hideVideo #left {
        flex: 0 0 0px;
        height: 0px;
        width: auto;
        border-bottom: 0;
      }
    }

    #playerWrap {
      position: relative;
      flex: 1 1 auto;
      min-height: 0;
      background: #000;
    }
    #player { position: absolute; inset: 0; width: 100%; height: 100%; }
    #player iframe { width: 100% !important; height: 100% !important; display: block; }

    #videoPi {
      position: absolute;
      top: 44px;
      left: 50%;
      transform: translateX(-50%);
      width: 28px;
      height: 28px;
      display: grid;
      place-items: center;
      z-index: 6;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      border-radius: 6px;
      border: 1.5px solid rgba(255,255,255,0.65);
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.15);
      font-family: system-ui, sans-serif;
      font-weight: 800;
      line-height: 1;
    }

    #videoPi:active {
      transform: translate(-50%, 0.5px);
    }

    .extraViz {
      flex: 1 1 auto;
      position: relative;
      min-width: 0;
      min-height: 0;
      background: #000;
    }

    .extraViz iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }

    #ytLoading {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      opacity: 0;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    #ytLoading.show { opacity: 1; }

    #viz { position: absolute; inset: 0; }
    #bevy-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }

    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-rows: 1fr auto 1fr;
      align-items: center;
      justify-items: center;
      padding: 4vmin;
    }

    /* Debug toast (used to confirm key chords are being detected). */
    #keyToast {
      position: fixed;
      right: 10px;
      top: 10px;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 120ms ease, transform 120ms ease;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.35);
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.65);
      font: 600 12px/1.25 system-ui, sans-serif;
      letter-spacing: 0.01em;
      white-space: nowrap;
    }

    #keyToast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .title {
      grid-row: 2;
      text-align: center;
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      line-height: 0.95;
      color: #F2B100;
      text-shadow:
        0 2px 0 rgba(0,0,0,0.35),
        0 10px 26px rgba(0,0,0,0.35);
      opacity: 0;
      transform: translateY(12px) scale(0.98);
      transition: opacity 260ms ease, transform 260ms ease;
      filter: saturate(1.15);
    }

    .title.show {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .title.wobble {
      animation: wobble 1.35s ease-in-out infinite;
    }

    @keyframes wobble {
      0%   { transform: translateY(0) scale(1) skewX(0deg); }
      25%  { transform: translateY(-1px) scale(1.01) skewX(-0.7deg); }
      50%  { transform: translateY(0) scale(1) skewX(0.7deg); }
      75%  { transform: translateY(1px) scale(0.995) skewX(-0.4deg); }
      100% { transform: translateY(0) scale(1) skewX(0deg); }
    }

    .caption {
      grid-row: 3;
      width: min(92%, 900px);
      text-align: center;
      font-size: clamp(16px, 2.2vw, 26px);
      line-height: 1.25;
      color: rgba(255,255,255,0.94);
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
      padding: 10px 14px;
      border-radius: 14px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.30), rgba(0,0,0,0.12));
      backdrop-filter: blur(4px);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }

    .caption.show {
      opacity: 1;
      transform: translateY(0);
    }

    .caption.meta {
      opacity: 0.55;
      font-style: italic;
    }

    #loading {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(6px);
      opacity: 0;
      transition: opacity 200ms ease;
      z-index: 10;
    }

    #loading.show {
      opacity: 1;
    }

    #loading .box {
      width: min(92vw, 640px);
      padding: 18px 18px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      text-align: center;
      line-height: 1.25;
    }

    #loading .title {
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: #F2B100;
      margin-bottom: 8px;
      font-size: 22px;
    }

    #loading .msg {
      font-size: 16px;
      opacity: 0.9;
    }

    #ytLoading .box {
      width: min(92vw, 520px);
      padding: 16px 16px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      text-align: center;
      line-height: 1.25;
    }

    #ytLoading .title {
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: #F2B100;
      margin-bottom: 6px;
      font-size: 20px;
    }

    #ytLoading .msg {
      font-size: 15px;
      opacity: 0.9;
    }

  /* controls removed — use egui overlay from wasm instead */
  </style>
</head>
<body>
  <div id="root">
    <div id="left">
      <div id="playerWrap">
        <div id="player"></div>

        <div id="videoPi" title="Add another viz">π</div>

        <div id="ytLoading" class="show">
          <div class="box">
            <div class="title">Loading YouTube…</div>
            <div class="msg" id="ytLoadingMsg">Preparing the player…</div>
          </div>
        </div>
      </div>
    </div>

    <div id="right">
      <div id="viz">
        <canvas id="bevy-canvas"></canvas>
      </div>

      <div id="loading" class="show">
        <div class="box">
          <div class="title">Hold on…</div>
          <div class="msg" id="loadingMsg">Loading the app (the model is large; this can take a moment)…</div>
        </div>
      </div>

      <div id="overlay">
        <div class="title" id="credit"></div>
        <div class="caption" id="caption"></div>
      </div>

  <!-- DOM controls removed — interactive UI is provided by Egui overlay inside the wasm app -->
    </div>
  </div>

  <script type="module">
    const VIDEO_ID = "v2hcW03gcus";

    const params = new URLSearchParams(window.location.search);
    const vizOnly = params.get("vizOnly") === "1";

    const creditEl = document.getElementById("credit");
    const captionEl = document.getElementById("caption");
    const rootEl = document.getElementById("root");
    const loadingEl = document.getElementById("loading");
    const loadingMsgEl = document.getElementById("loadingMsg");
    const ytLoadingEl = document.getElementById("ytLoading");
    const ytLoadingMsgEl = document.getElementById("ytLoadingMsg");
    const videoPiEl = document.getElementById("videoPi");
    const PAGE_ORIGIN = window.location.origin;

    // Small toast to confirm key detection (useful when DevTools shortcuts are blocked).
    const keyToastEl = (() => {
      const el = document.createElement("div");
      el.id = "keyToast";
      el.textContent = "";
      document.body.appendChild(el);
      return el;
    })();

    let keyToastTimer = null;
    function showKeyToast(text) {
      if (!keyToastEl) return;
      keyToastEl.textContent = text;
      keyToastEl.classList.add("show");
      if (keyToastTimer) clearTimeout(keyToastTimer);
      keyToastTimer = setTimeout(() => keyToastEl.classList.remove("show"), 900);
    }

    // Two-step devtools helper: first press focuses the page, second press triggers `debugger;`.
    let devtoolsChordPrimedUntilMs = 0;
    function focusForDevtools() {
      // Make sure our targets can be focused programmatically.
      // (tabIndex=-1 keeps them out of normal tab order.)
      try {
        rootEl.tabIndex = -1;
      } catch (_) {}
      const playerWrapEl = document.getElementById("playerWrap");
      try {
        if (playerWrapEl) playerWrapEl.tabIndex = -1;
      } catch (_) {}

      // Ask the window/document to focus, then focus a stable element.
      try {
        window.focus();
      } catch (_) {}
      try {
        rootEl.focus({ preventScroll: true });
      } catch (_) {
        try {
          rootEl.focus();
        } catch (_) {}
      }

      // If we're not in vizOnly, also try focusing the player wrapper.
      if (!vizOnly && playerWrapEl) {
        try {
          playerWrapEl.focus({ preventScroll: true });
        } catch (_) {
          try {
            playerWrapEl.focus();
          } catch (_) {}
        }
      }
    }

    // Best-effort: some embedded hosts (or focus states) may not open DevTools with Ctrl+Shift+I.
    // Browsers do not expose an API to open DevTools directly, but a `debugger` statement often
    // prompts DevTools to open when available.
    window.addEventListener(
      "keydown",
      (e) => {
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === "I" || e.key === "i")) {
          // Do not preventDefault() here: in real browsers this is a built-in DevTools shortcut.
          const now = Date.now();
          if (now <= devtoolsChordPrimedUntilMs) {
            showKeyToast("Ctrl+Shift+I again (debugger)");
            debugger;
          } else {
            devtoolsChordPrimedUntilMs = now + 2000;
            focusForDevtools();
            showKeyToast("Ctrl+Shift+I (focused) — press again");
          }
        }
      },
      { capture: true }
    );

    let wasmReady = false;
    let ytReady = false;
    let bootFailed = false;

    function setVizLoading(show, text) {
      loadingEl.classList.toggle("show", !!show);
      if (typeof text === "string" && text.length && loadingMsgEl) {
        loadingMsgEl.textContent = text;
      }
    }

    function setYoutubeLoading(show, text) {
      ytLoadingEl.classList.toggle("show", !!show);
      if (typeof text === "string" && text.length && ytLoadingMsgEl) {
        ytLoadingMsgEl.textContent = text;
      }
    }

    function refreshLoading() {
      if (bootFailed) {
        setVizLoading(true, "Failed to load the app. Check the console for details.");
        setYoutubeLoading(true, "YouTube may also fail to load.");
        return;
      }
      if (!wasmReady) {
        setVizLoading(true, "Loading the app (this can take a moment)…");
        return;
      }
      setVizLoading(false, "");

      if (!ytReady) {
        setYoutubeLoading(true, "Preparing the player…");
        return;
      }

      setYoutubeLoading(false, "");
    }

    // Called from Rust (wasm) to update overlays.
    // Important: wasm-bindgen glue runs in ES module scope; refer to these via `globalThis.*`.
    globalThis.mcbaise_set_credit = (html, show) => {
      if (!show) {
        creditEl.classList.remove("show", "wobble");
        creditEl.innerHTML = "";
        return;
      }
      creditEl.innerHTML = html;
      creditEl.classList.add("show", "wobble");
    };

    globalThis.mcbaise_set_caption = (text, show, isMeta) => {
      if (!show) {
        captionEl.classList.remove("show", "meta");
        captionEl.textContent = "";
        return;
      }
      captionEl.textContent = text;
      captionEl.classList.add("show");
      captionEl.classList.toggle("meta", !!isMeta);
    };

    // Called from Rust (wasm) to show/hide the YouTube pane.
    // "Hide" means collapse the left column to 0 width.
    globalThis.mcbaise_set_video_visible = (show) => {
      rootEl.classList.toggle("hideVideo", !show);
    };

    // Loading overlay control. Called both from JS boot and from Rust (wasm) once ready.
    // Back-compat: still allow wasm/JS to control the viz overlay directly.
    globalThis.mcbaise_set_loading = (show, text) => setVizLoading(show, text);

    // Called from Rust (wasm) once the startup scene has been created.
    globalThis.mcbaise_set_wasm_ready = () => {
      wasmReady = true;
      refreshLoading();
    };

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    // Boot wasm.
    let wasm = null;
    async function bootWasm() {
      wasmReady = false;
      bootFailed = false;
      refreshLoading();
      // Bust cache for both the JS glue and the wasm binary.
      // This prevents running an older cached glue file that may still reference missing globals.
      const v = Date.now().toString();
      setVizLoading(true, "Downloading WebAssembly…");
      const mod = await import(`./pkg/bevy_mcbaise_fantasmagoria.js?v=${v}`);
      // wasm-bindgen requires explicit initialization; otherwise exports will exist but call into
      // an uninitialized internal `wasm` instance.
      setVizLoading(true, "Initializing WebAssembly…");
      await mod.default({ module_or_path: `./pkg/bevy_mcbaise_fantasmagoria_bg.wasm?v=${v}` });
      wasm = mod;
      // The app will call `mcbaise_set_wasm_ready()` from Rust when it finishes startup.
      refreshLoading();
    }

    // YouTube player.
    let player = null;
    let playerReady = false;
    let isPlaying = false;
    let rafId = null;
    let pollId = null;
    let pendingPlayingRequest = null;

    // Extra viz instances are injected as iframes so they can run a separate wasm app.
    // This avoids wasm-bindgen's single-instance limitation within one document.
    const extraVizFrames = [];

    function broadcastTime(timeSec, playing) {
      for (const frame of extraVizFrames) {
        try {
          frame?.contentWindow?.postMessage({ type: "mcbaise_time", timeSec, playing: !!playing }, PAGE_ORIGIN);
        } catch (_) {}
      }
    }

    // Receive play/pause requests from child viz iframes.
    window.addEventListener("message", (e) => {
      if (e.origin !== PAGE_ORIGIN) return;
      const data = e.data;
      if (!data || typeof data !== "object") return;
      if (data.type === "mcbaise_request_playing") {
        globalThis.mcbaise_request_playing(!!data.playing);
      }
    });

    // Called from Rust (wasm) to request play/pause.
    // Note: may be called before the YouTube player is ready.
    globalThis.mcbaise_request_playing = (playing) => {
      if (vizOnly) {
        // In a viz-only iframe: ask the parent to control the video.
        try {
          window.parent?.postMessage({ type: "mcbaise_request_playing", playing: !!playing }, PAGE_ORIGIN);
        } catch (_) {}
        return;
      }

      const want = !!playing;
      pendingPlayingRequest = want;

      if (!playerReady || !player) return;
      try {
        if (want) player.playVideo?.();
        else player.pauseVideo?.();
      } catch (e) {
        console.warn('mcbaise_request_playing failed', e);
      }
    };

    function startLoop() {
      if (rafId) return;
      const loop = () => {
        rafId = requestAnimationFrame(loop);
        if (!wasm?.set_video_time || !playerReady || !player?.getCurrentTime) return;
        const t = player.getCurrentTime();
        wasm.set_video_time(t, !!isPlaying);
        broadcastTime(t, !!isPlaying);
      };
      loop();
    }

    function stopLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function startPoll() {
      if (pollId) return;
      pollId = setInterval(() => {
        if (!wasm?.set_video_time || !playerReady || !player?.getCurrentTime) return;
        const t = player.getCurrentTime();
        wasm.set_video_time(t, !!isPlaying);
        broadcastTime(t, !!isPlaying);
      }, 250);
    }

    function stopPoll() {
      if (pollId) clearInterval(pollId);
      pollId = null;
    }

    window.onYouTubeIframeAPIReady = () => {
      ytReady = false;
      setYoutubeLoading(true, "Preparing the player…");
      refreshLoading();
      player = new YT.Player("player", {
        videoId: VIDEO_ID,
        width: "100%",
        height: "100%",
        playerVars: {
          autoplay: 0,
          controls: 1,
          rel: 0,
          modestbranding: 1,
          playsinline: 1,
          enablejsapi: 1,
          // Required on some browsers/devices to avoid postMessage origin mismatch.
          origin: PAGE_ORIGIN,
        },
        events: {
          onReady: () => {
            playerReady = true;
            ytReady = true;
            setYoutubeLoading(false, "");
            refreshLoading();
            const t = player.getCurrentTime?.() ?? 0;
            wasm?.set_video_time?.(t, false);
            broadcastTime(t, false);

            if (pendingPlayingRequest !== null) {
              try {
                if (pendingPlayingRequest) player.playVideo?.();
                else player.pauseVideo?.();
              } catch (e) {
                console.warn('mcbaise_request_playing (deferred) failed', e);
              }
            }
          },
          onStateChange: (e) => {
            if (e.data === YT.PlayerState.PLAYING) {
              isPlaying = true;
              startLoop();
              startPoll();
            } else {
              isPlaying = false;
              const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
              wasm?.set_video_time?.(t, false);
              broadcastTime(t, false);
              stopLoop();
              stopPoll();
            }
          },
          onPlaybackRateChange: () => {
            // Keep wasm time/playing fresh when playback rate changes.
            const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
            wasm?.set_video_time?.(t, !!isPlaying);
            broadcastTime(t, !!isPlaying);
          },
          onError: (err) => {
            console.warn('YouTube player error', err);
            const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
            wasm?.set_video_time?.(t, false);
            broadcastTime(t, false);
            stopLoop();
            stopPoll();
          }
        }
      });
    };

    // In viz-only mode, receive time updates from the parent page.
    window.addEventListener("message", (e) => {
      if (e.origin !== PAGE_ORIGIN) return;
      const data = e.data;
      if (!data || typeof data !== "object") return;
      if (data.type === "mcbaise_time") {
        wasm?.set_video_time?.(Number(data.timeSec) || 0, !!data.playing);
      }
    });

    function injectExtraViz() {
      if (vizOnly) return;
      // Keep it simple: only inject one extra viz per click.
      // Additional clicks will inject another iframe.
      const pane = document.createElement("div");
      pane.className = "extraViz";

      const iframe = document.createElement("iframe");
      iframe.loading = "lazy";
      iframe.title = "mcbaise viz";

      const u = new URL(window.location.href);
      u.searchParams.set("vizOnly", "1");
      iframe.src = u.toString();

      pane.appendChild(iframe);

      const left = document.getElementById("left");
      const playerWrap = document.getElementById("playerWrap");
      const right = document.getElementById("right");

      // Random placement:
      // 0: new column left of the video
      // 1: new column right of the video (between video and main viz)
      // 2: inside video pane, above the player
      // 3: inside video pane, below the player
      const placement = Math.floor(Math.random() * 4);
      if (placement === 0 && left) {
        rootEl.insertBefore(pane, left);
      } else if (placement === 1 && right) {
        rootEl.insertBefore(pane, right);
      } else if (placement === 2 && left && playerWrap) {
        left.insertBefore(pane, playerWrap);
      } else if (placement === 3 && left && playerWrap) {
        // Guaranteed "bottom": append after the playerWrap.
        left.appendChild(pane);
      } else {
        // Fallback: keep the app usable even if the DOM changed.
        (left || rootEl).appendChild(pane);
      }

      extraVizFrames.push(iframe);

      // Push an initial time sample as soon as possible.
      const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
      broadcastTime(t, !!isPlaying);
    }


    async function main() {
      try {
        await bootWasm();
      } catch (err) {
        console.error(err);
        bootFailed = true;
        refreshLoading();
        throw err;
      }
      if (vizOnly) {
        // Viz-only iframe: no YouTube; parent will drive time via postMessage.
        ytReady = true;
        setYoutubeLoading(false, "");
        refreshLoading();
        rootEl.classList.add("hideVideo");
        if (videoPiEl) videoPiEl.style.display = "none";
        return;
      }

      // DOM controls were removed; the wasm app uses an egui overlay for runtime controls.
      setYoutubeLoading(true, "Loading YouTube…");
      await loadScript("https://www.youtube.com/iframe_api");
    }

    if (videoPiEl) {
      videoPiEl.addEventListener("click", () => injectExtraViz());
    }

    main().catch(err => console.error(err));
  </script>
</body>
</html>
