<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="favicon.ico" sizes="any" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <title>MCBAISE • PALE REGARD • ABSURDIA FANTASMAGORIA</title>
  <script>
    // vizOnly iframes should never show the YouTube pane/loading UI.
    // Do this in the head to avoid a flash before the module script runs.
    try {
      const p = new URLSearchParams(location.search);
      if (p.get('vizOnly') === '1') document.documentElement.classList.add('vizOnly');
      // Debug flag via query string: ?debug will enable verbose instrumentation.
      const DEBUG_MCBAISE = p.get('debug') === '1' || p.get('debug') === 'true' || p.has('debug');
      // Expose for other scripts
      window.__MCBAISE_DEBUG = !!DEBUG_MCBAISE;
      // If debug is not enabled, silence all console output to avoid noisy
      // logs during normal usage and profiling. When debug is enabled, restore
      // original console methods.
      try {
        const _orig = {
          log: console.log && console.log.bind(console),
          info: console.info && console.info.bind(console),
          warn: console.warn && console.warn.bind(console),
          error: console.error && console.error.bind(console),
          debug: console.debug && console.debug.bind(console),
        };
        // Always keep warn/error available so runtime issues surface.
        try { if (_orig.warn) console.warn = _orig.warn; } catch (_) {}
        try { if (_orig.error) console.error = _orig.error; } catch (_) {}

        // Wrap log/info/debug so they only emit when our debug flag is set.
        const guarded = (orig) => function(...args) {
          try {
            if (window.__MCBAISE_DEBUG) return orig && orig(...args);
          } catch (_) {}
        };
        try { console.log = guarded(_orig.log); } catch (_) {}
        try { console.info = guarded(_orig.info); } catch (_) {}
        try { console.debug = guarded(_orig.debug || _orig.log); } catch (_) {}
      } catch (_) {}
      // Notify the service worker to enable debug logs when requested.
      try {
        if (window.__MCBAISE_DEBUG && 'serviceWorker' in navigator) {
          try {
            // Prefer the active worker if ready.
            navigator.serviceWorker.ready.then(reg => {
              try { reg.active?.postMessage?.({ type: 'SW_DEBUG_ENABLE' }); } catch (_) {}
            }).catch(() => {});
            // Also attempt direct controller postMessage (if available earlier).
            try { navigator.serviceWorker.controller?.postMessage?.({ type: 'SW_DEBUG_ENABLE' }); } catch (_) {}
          } catch (_) {}
        }
      } catch (_) {}

      // Long task observer: log heavy tasks when debug enabled.
      try {
        if (typeof PerformanceObserver !== 'undefined') {
          const po = new PerformanceObserver((list) => {
            if (!window.__MCBAISE_DEBUG) return;
            for (const e of list.getEntries()) {
              try {
                if (e.duration && e.duration > 50) console.warn('mcbaise:longtask', { name: e.name, duration: e.duration, entry: e });
              } catch (_) {}
            }
          });
          try { po.observe({ type: 'longtask', buffered: true }); } catch (_) {}
        }
      } catch (_) {}
    } catch (_) {}
  </script>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Baloo+2:wght@700;800&display=swap");

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }

    #root { height: 100%; display: flex; }

    /* vizOnly iframes: hide the YouTube pane entirely (no flash). */
    .vizOnly #left { display: none !important; }
    .vizOnly #ytLoading,
    .vizOnly #playerWrap,
     /* vizOnly: don't hide the cardinal pi container — viz-only frames shouldn't show the player, but
       the control overlay must remain usable when present in the parent document. */

    /* vizOnly: do not show captions; credits are allowed. */
    .vizOnly #caption { display: none !important; }

    #left, #right {
      flex: 1;
      position: relative;
      min-width: 0;
    }

    #left {
      border-right: 2px solid rgba(255,255,255,0.12);
      background: #000;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    /* Landscape: hide video by collapsing width. */
    #root.hideVideo #left {
      flex: 0 0 0px;
      width: 0px;
      border-right: 0;
    }

    /* Portrait (more tall than wide): stack vertically (video above, viz below). */
    @media (max-aspect-ratio: 1/1) {
      #root { flex-direction: column; }

      #left {
        border-right: 0;
        border-bottom: 2px solid rgba(255,255,255,0.12);
      }

      /* Give the video a reasonable default height in portrait. */
      #left { flex: 0 0 40%; }
      #right { flex: 1 1 auto; }

      /* Portrait: hide video by collapsing height. */
      #root.hideVideo #left {
        flex: 0 0 0px;
        height: 0px;
        width: auto;
        border-bottom: 0;
      }
    }

    #playerWrap {
      position: relative;
      flex: 1 1 auto;
      min-height: 0;
      background: #000;
      isolation: isolate;
    }
    /* When hiding video we only hide the player contents, not the entire left column,
       so viz panes inserted above/below remain present. */
     /* hide only the player contents and collapse the player area so it doesn't
       take vertical space between N and S viz panes */
     #playerWrap.hidePlayer { flex: 0 0 0px; height: 0px; min-height: 0; overflow: hidden; padding: 0; }
     #playerWrap.hidePlayer #player { display: none !important; }
     #playerWrap.hidePlayer #ytLoading { display: none !important; }
    #player { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 1; }
    #player iframe { width: 100% !important; height: 100% !important; display: block; }

    /* Legacy single-π CSS removed; use the cardinal buttons in #videoPiContainer. */

    /* container for the 4 cardinal π buttons: top-level fixed overlay so it's always on top */
    #videoPiContainer { position: fixed; inset: 0; pointer-events: none; z-index: 100000; }
    .videoPi {
      position: absolute;
      width: 34px;
      height: 34px;
      display: grid;
      place-items: center;
      border-radius: 8px;
      border: 1.2px solid rgba(255,255,255,0.65);
      background: rgba(0,0,0,0.15);
      color: rgba(255,255,255,0.95);
      font-weight: 800;
      cursor: pointer;
      pointer-events: auto;
      z-index: 40;
    }
    .videoPi[data-dir="top"] { left: 50%; transform: translateX(-50%); top: calc(env(safe-area-inset-top, 0px) + 8px); }
    .videoPi[data-dir="bottom"] { left: 50%; transform: translateX(-50%); bottom: calc(env(safe-area-inset-bottom, 0px) + 8px); }
    .videoPi[data-dir="left"] { left: 8px; top: 50%; transform: translateY(-50%); }
    .videoPi[data-dir="right"] { right: 8px; top: 50%; transform: translateY(-50%); }

    /* hidden by default; toggled by .show on container */
    #videoPiContainer { opacity: 0; transition: opacity 140ms ease; }
    #videoPiContainer.show { opacity: 1; }

    .extraViz {
      flex: 1 1 auto;
      position: relative;
      min-width: 0;
      min-height: 0;
      background: #000;
    }

    .extraViz iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }

    #ytLoading {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      opacity: 0;
      transition: opacity 200ms ease;
      z-index: 5;
    }

    #ytLoading.show { opacity: 1; }

    #viz { position: absolute; inset: 0; }
    #bevy-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }

    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-rows: 1fr auto 1fr;
      align-items: center;
      justify-items: center;
      padding: 4vmin;
    }

    /* Debug toast (used to confirm key chords are being detected). */
    #keyToast {
      position: fixed;
      right: 10px;
      top: 10px;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity 120ms ease, transform 120ms ease;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.35);
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.65);
      font: 600 12px/1.25 system-ui, sans-serif;
      letter-spacing: 0.01em;
      white-space: nowrap;
    }

    #keyToast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .title {
      grid-row: 2;
      text-align: center;
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      line-height: 0.95;
      color: #F2B100;
      text-shadow:
        0 2px 0 rgba(0,0,0,0.35),
        0 10px 26px rgba(0,0,0,0.35);
      opacity: 0;
      transform: translateY(12px) scale(0.98);
      transition: opacity 260ms ease, transform 260ms ease;
      filter: saturate(1.15);
    }

    .title.show {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .title.wobble {
      animation: wobble 1.35s ease-in-out infinite;
    }

    @keyframes wobble {
      0%   { transform: translateY(0) scale(1) skewX(0deg); }
      25%  { transform: translateY(-1px) scale(1.01) skewX(-0.7deg); }
      50%  { transform: translateY(0) scale(1) skewX(0.7deg); }
      75%  { transform: translateY(1px) scale(0.995) skewX(-0.4deg); }
      100% { transform: translateY(0) scale(1) skewX(0deg); }
    }

    .caption {
      grid-row: 3;
      width: min(92%, 900px);
      text-align: center;
      font-size: clamp(16px, 2.2vw, 26px);
      line-height: 1.25;
      color: rgba(255,255,255,0.94);
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
      padding: 10px 14px;
      border-radius: 14px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.30), rgba(0,0,0,0.12));
      backdrop-filter: blur(4px);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 180ms ease, transform 180ms ease;
    }

    .caption.show {
      opacity: 1;
      transform: translateY(0);
    }

    .caption.meta {
      opacity: 0.55;
      font-style: italic;
    }

    #loading {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(6px);
      opacity: 0;
      transition: opacity 200ms ease;
      z-index: 10;
    }

    #loading.show {
      opacity: 1;
    }

    #loading .box {
      width: min(92vw, 640px);
      padding: 18px 18px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      text-align: center;
      line-height: 1.25;
    }

    #loading .title {
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: #F2B100;
      margin-bottom: 8px;
      font-size: 22px;
    }

    #loading .msg {
      font-size: 16px;
      opacity: 0.9;
    }

    #ytLoading .box {
      width: min(92vw, 520px);
      padding: 16px 16px;
      border-radius: 14px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      text-align: center;
      line-height: 1.25;
    }

    #ytLoading .title {
      font-family: "Baloo 2", system-ui, sans-serif;
      font-weight: 800;
      letter-spacing: 0.02em;
      color: #F2B100;
      margin-bottom: 6px;
      font-size: 20px;
    }

    #ytLoading .msg {
      font-size: 15px;
      opacity: 0.9;
    }

  /* controls removed — use egui overlay from wasm instead */
  </style>
</head>
<body>
  <div id="root">
    <div id="left">
      <div id="playerWrap">
        <div id="player"></div>

        <!-- videoPiContainer moved to top-level (inserted after #root) -->

        <div id="ytLoading" class="show">
          <div class="box">
            <div class="title">Loading YouTube…</div>
            <div class="msg" id="ytLoadingMsg">Preparing the player…</div>
          </div>
        </div>
      </div>
    </div>

    <div id="right">
      <div id="viz">
        <canvas id="bevy-canvas"></canvas>
      </div>

      <div id="loading" class="show">
        <div class="box">
          <div class="title">Hold on…</div>
          <div class="msg" id="loadingMsg">Loading the app (the model is large; this can take a moment)…</div>
        </div>
      </div>

      <div id="overlay">
        <div class="title" id="credit"></div>
        <div class="caption" id="caption"></div>
      </div>

  <!-- DOM controls removed — interactive UI is provided by Egui overlay inside the wasm app -->
    </div>
  </div>

  <!-- Top-level cardinal π container: always fixed above all content. -->
  <div id="videoPiContainer" aria-hidden="true">
    <button class="videoPi" data-dir="top" title="Add viz above">N</button>
    <button class="videoPi" data-dir="right" title="Add viz right">E</button>
    <button class="videoPi" data-dir="bottom" title="Add viz below">S</button>
    <button class="videoPi" data-dir="left" title="Add viz left">W</button>
  </div>

  <script type="module">
    const VIDEO_ID = "v2hcW03gcus";

    const params = new URLSearchParams(window.location.search);
    const vizOnly = params.get("vizOnly") === "1";

    const creditEl = document.getElementById("credit");
    const captionEl = document.getElementById("caption");
    const rootEl = document.getElementById("root");
    const loadingEl = document.getElementById("loading");
    const loadingMsgEl = document.getElementById("loadingMsg");
    const ytLoadingEl = document.getElementById("ytLoading");
    const ytLoadingMsgEl = document.getElementById("ytLoadingMsg");
    const videoPiContainer = document.getElementById("videoPiContainer");
    const playerWrapEl = document.getElementById("playerWrap");
    const PAGE_ORIGIN = window.location.origin;

    // Small toast to confirm key detection (useful when DevTools shortcuts are blocked).
    const keyToastEl = (() => {
      const el = document.createElement("div");
      el.id = "keyToast";
      el.textContent = "";
      document.body.appendChild(el);
      return el;
    })();

    let keyToastTimer = null;
    function showKeyToast(text) {
      if (!keyToastEl) return;
      keyToastEl.textContent = text;
      keyToastEl.classList.add("show");
      if (keyToastTimer) clearTimeout(keyToastTimer);
      keyToastTimer = setTimeout(() => keyToastEl.classList.remove("show"), 900);
    }

    // Two-step devtools helper: first press focuses the page, second press triggers `debugger;`.
    let devtoolsChordPrimedUntilMs = 0;
    function focusForDevtools() {
      // Make sure our targets can be focused programmatically.
      // (tabIndex=-1 keeps them out of normal tab order.)
      try {
        rootEl.tabIndex = -1;
      } catch (_) {}
      const playerWrapEl = document.getElementById("playerWrap");
      try {
        if (playerWrapEl) playerWrapEl.tabIndex = -1;
      } catch (_) {}

      // Ask the window/document to focus, then focus a stable element.
      try {
        window.focus();
      } catch (_) {}
      try {
        rootEl.focus({ preventScroll: true });
      } catch (_) {
        try {
          rootEl.focus();
        } catch (_) {}
      }

      // If we're not in vizOnly, also try focusing the player wrapper.
      if (!vizOnly && playerWrapEl) {
        try {
          playerWrapEl.focus({ preventScroll: true });
        } catch (_) {
          try {
            playerWrapEl.focus();
          } catch (_) {}
        }
      }
    }

    // Best-effort: some embedded hosts (or focus states) may not open DevTools with Ctrl+Shift+I.
    // Browsers do not expose an API to open DevTools directly, but a `debugger` statement often
    // prompts DevTools to open when available.
    window.addEventListener(
      "keydown",
      (e) => {
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === "I" || e.key === "i")) {
          // Do not preventDefault() here: in real browsers this is a built-in DevTools shortcut.
          const now = Date.now();
          if (now <= devtoolsChordPrimedUntilMs) {
            showKeyToast("Ctrl+Shift+I again (debugger)");
            debugger;
          } else {
            devtoolsChordPrimedUntilMs = now + 2000;
            focusForDevtools();
            showKeyToast("Ctrl+Shift+I (focused) — press again");
          }
        }
      },
      { capture: true }
    );

    // Ctrl/Cmd+D toggles MCBAISE debug mode (lightweight). Note: this
    // overrides the browser's default bookmark shortcut. It persists the
    // choice to localStorage and notifies the service worker.
    function setDebugEnabled(enabled) {
      try {
        window.__MCBAISE_DEBUG = !!enabled;
        try { localStorage.setItem('mcbaise_debug', window.__MCBAISE_DEBUG ? '1' : '0'); } catch (_) {}
        // Notify SW
        try {
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.ready.then(reg => { try { reg.active?.postMessage?.({ type: window.__MCBAISE_DEBUG ? 'SW_DEBUG_ENABLE' : 'SW_DEBUG_DISABLE' }); } catch (_) {} }).catch(() => {});
            try { navigator.serviceWorker.controller?.postMessage?.({ type: window.__MCBAISE_DEBUG ? 'SW_DEBUG_ENABLE' : 'SW_DEBUG_DISABLE' }); } catch (_) {}
          }
        } catch (_) {}
        try { showKeyToast(window.__MCBAISE_DEBUG ? 'Debug ON' : 'Debug OFF'); } catch (_) {}
      } catch (_) {}
    }

    function toggleDebug() { setDebugEnabled(!window.__MCBAISE_DEBUG); }

    window.addEventListener('keydown', (e) => {
      try {
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'd' || e.key === 'D')) {
          // Prevent default browser action (bookmark) only when we successfully toggle
          try { e.preventDefault(); } catch (_) {}
          toggleDebug();
        }
      } catch (_) {}
    }, { capture: true });

    // Respect persisted debug setting if querystring didn't explicitly enable debug.
    try {
      if (!window.__MCBAISE_DEBUG) {
        try {
          const s = localStorage.getItem('mcbaise_debug');
          if (s === '1') {
            setDebugEnabled(true);
          }
        } catch (_) {}
      }
    } catch (_) {}

    let wasmReady = false;
    let ytReady = false;
    let bootFailed = false;

    function setVideoPiVisible(show) {
      if (!videoPiContainer) return;
      videoPiContainer.classList.toggle("show", !!show);
    }

    function setVizLoading(show, text) {
      loadingEl.classList.toggle("show", !!show);
      if (typeof text === "string" && text.length && loadingMsgEl) {
        loadingMsgEl.textContent = text;
      }
    }

    function setYoutubeLoading(show, text) {
      ytLoadingEl.classList.toggle("show", !!show);
      if (typeof text === "string" && text.length && ytLoadingMsgEl) {
        ytLoadingMsgEl.textContent = text;
      }
    }

    function refreshLoading() {
      // Only show the DOM π control when both halves are ready.
      // (And never in vizOnly iframes.)
      // Debug: log readiness to help diagnose premature visibility issues.
      console.debug('refreshLoading:', { vizOnly, bootFailed, wasmReady, ytReady });
      setVideoPiVisible(!vizOnly && !bootFailed && wasmReady && ytReady);
      if (bootFailed) {
        setVizLoading(true, "Failed to load the app. Check the console for details.");
        setYoutubeLoading(true, "YouTube may also fail to load.");
        return;
      }
      if (!wasmReady) {
        setVizLoading(true, "Loading the app (this can take a moment)…");
        return;
      }
      setVizLoading(false, "");

      if (!ytReady) {
        setYoutubeLoading(true, "Preparing the player…");
        return;
      }

      setYoutubeLoading(false, "");
    }

    // Called from Rust (wasm) to update overlays.
    // Important: wasm-bindgen glue runs in ES module scope; refer to these via `globalThis.*`.
    globalThis.mcbaise_set_credit = (html, show) => {
      if (!show) {
        creditEl.classList.remove("show", "wobble");
        creditEl.innerHTML = "";
        return;
      }
      creditEl.innerHTML = html;
      creditEl.classList.add("show", "wobble");
    };

    globalThis.mcbaise_set_caption = (text, show, isMeta) => {
      if (vizOnly) {
        // vizOnly iframes: captions are hidden by default.
        captionEl.classList.remove("show", "meta");
        captionEl.textContent = "";
        return;
      }
      if (!show) {
        captionEl.classList.remove("show", "meta");
        captionEl.textContent = "";
        return;
      }
      captionEl.textContent = text;
      captionEl.classList.add("show");
      captionEl.classList.toggle("meta", !!isMeta);
      // Nudge child frames when captions change — this can unstick throttled
      // or backgrounded iframes in some UAs. Best-effort authoritative sync.
      try {
        const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
        try { broadcastSync(t, !!isPlaying); } catch (_) {}
      } catch (_) {}
    };

    // Called from Rust (wasm) to show/hide the YouTube pane.
    // "Hide" means collapse the left column to 0 width.
    globalThis.mcbaise_set_video_visible = (show) => {
      if (vizOnly) {
        // Forward to parent: only the parent actually owns the YouTube pane.
        try {
          window.parent?.postMessage({ type: "mcbaise_set_video_visible", show: !!show }, PAGE_ORIGIN);
        } catch (_) {}
        return;
      }
      setVideoVisibility(!!show);
    };

    // Loading overlay control. Called both from JS boot and from Rust (wasm) once ready.
    // Back-compat: still allow wasm/JS to control the viz overlay directly.
    globalThis.mcbaise_set_loading = (show, text) => setVizLoading(show, text);

    // Called from Rust (wasm) once the startup scene has been created.
    globalThis.mcbaise_set_wasm_ready = () => {
      wasmReady = true;
      refreshLoading();
    };

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    // Boot wasm.
    let wasm = null;
    async function bootWasm() {
      wasmReady = false;
      bootFailed = false;
      refreshLoading();
      // Bust cache for both the JS glue and the wasm binary.
      // This prevents running an older cached glue file that may still reference missing globals.
      const v = Date.now().toString();
      setVizLoading(true, "Downloading WebAssembly…");
      const mod = await import(`./pkg/bevy_mcbaise_fantasmagoria.js?v=${v}`);
      // wasm-bindgen requires explicit initialization; otherwise exports will exist but call into
      // an uninitialized internal `wasm` instance.
      setVizLoading(true, "Initializing WebAssembly…");
      await mod.default({ module_or_path: `./pkg/bevy_mcbaise_fantasmagoria_bg.wasm?v=${v}` });
      wasm = mod;
      // The app will call `mcbaise_set_wasm_ready()` from Rust when it finishes startup.
      refreshLoading();
    }

    // Rate-capped coalescer for `wasm.set_video_time`.
    // - Coalesces rapid updates and only flushes the latest time.
    // - Enforces a minimum interval (`WASM_MIN_INTERVAL_MS`) to avoid saturating
    //   the main thread when many frames or messages arrive.
    // - Uses `requestIdleCallback` when available to prefer idle time, falling
    //   back to `setTimeout`.
    let _wasmPending = null;
    let _wasmPendingTimer = null;
    let _wasmPendingIsIdle = false;
    let _wasmLastFlush = 0;
    const WASM_MIN_INTERVAL_MS = 33; // ~30Hz

    function _flushWasmPending() {
      try {
        const args = _wasmPending || { timeSec: 0, playing: false };
        _wasmPending = null;
        // clear the timer id (either idle callback id or timeout id)
        _wasmPendingTimer = null;
        _wasmPendingIsIdle = false;
        _wasmLastFlush = performance.now();
        if (typeof wasm?.set_video_time === 'function') {
          try { wasm.set_video_time(args.timeSec, !!args.playing); } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:schedule:flush:error', e); }
        }
      } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:schedule:flush:outer', e); }
    }

    function scheduleWasmSetVideoTime(timeSec, playing) {
      try {
        _wasmPending = { timeSec: Number(timeSec) || 0, playing: !!playing };
        // If a flush is already scheduled, just coalesce into _wasmPending.
        if (_wasmPendingTimer) return;

        const now = performance.now();
        const since = now - (_wasmLastFlush || 0);
        const scheduleImmediately = since >= WASM_MIN_INTERVAL_MS;

        const doSchedule = (delay) => {
          try {
            if (typeof requestIdleCallback !== 'undefined' && scheduleImmediately) {
              // Try to use idle time but cap timeout so we don't delay too long.
              try {
                _wasmPendingIsIdle = true;
                _wasmPendingTimer = requestIdleCallback(() => _flushWasmPending(), { timeout: 50 });
              } catch (_) {
                _wasmPendingIsIdle = false;
                _wasmPendingTimer = setTimeout(() => _flushWasmPending(), 0);
              }
            } else {
              // Either we are inside the min-interval window or RIC unavailable.
              _wasmPendingIsIdle = false;
              _wasmPendingTimer = setTimeout(() => _flushWasmPending(), delay);
            }
          } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:schedule:doSchedule:error', e); }
        };

        if (scheduleImmediately) {
          doSchedule(0);
        } else {
          // schedule after remaining interval to enforce rate cap
          const delay = Math.max(0, Math.ceil(WASM_MIN_INTERVAL_MS - since));
          doSchedule(delay);
        }
      } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:schedule:error', e); }
    }

    // YouTube player.
    let player = null;
    let playerReady = false;
    let isPlaying = false;
    let rafId = null;
    let pollId = null;
    let lastBroadcastMs = 0;
    // Throttle advisory 'tick' broadcasts to avoid saturating the renderer
    // while keeping visuals reasonably smooth. Use ~100ms (≈10Hz) by default.
    // Authoritative syncs remain controlled by `SYNC_THROTTLE_MS`.
    const BROADCAST_THROTTLE_MS = 100; // ms between non-authoritative ticks (~10Hz)
    let lastSyncSentMs = 0;
    let SYNC_THROTTLE_MS = 5000; // send authoritative syncs at ~0.2Hz (visible divergence)
    let pendingPlayingRequest = null;

    // Helper: schedule DOM writes on the next animation frame cycle (double-buffer)
    function scheduleWrite(fn) {
      requestAnimationFrame(() => requestAnimationFrame(fn));
    }

    // We always prefer local interpolation on children for smooth visuals.
    // The parent will continue to send authoritative syncs at `SYNC_THROTTLE_MS`.

    // Extra viz instances are injected as iframes so they can run a separate wasm app.
    // This avoids wasm-bindgen's single-instance limitation within one document.
    // Track injected viz iframes as objects so we can retry/post-initialize reliably.
    const extraVizFrames = [];
    // Observers and policy settings for priority/backoff
    const MAX_FULL_QUALITY = 3; // keep top N frames at full quality
    let io = null; // IntersectionObserver
    try {
      io = new IntersectionObserver((entries) => {
        for (const ent of entries) {
          const f = extraVizFrames.find(x => x.iframe === ent.target);
          if (f) {
            f._intersectionRatio = ent.intersectionRatio;
            updateFramePolicy(f);
          }
        }
        updateAllPolicies();
      }, { threshold: [0, 0.01, 0.1, 0.25, 0.5, 0.75, 1] });
    } catch (_) { io = null; }

    function sendPolicyToFrame(f, policy) {
      try {
        if (f.port && typeof f.port.postMessage === 'function') {
          f.port.postMessage({ type: 'policy', policy });
        } else {
          _postToFrame(f, { type: 'policy', policy });
        }
      } catch (e) { console.warn('mcbaise:sendPolicy failed', e); }
    }

    function computePriorityScore(f) {
      // Higher is better. Use intersection ratio and size.
      try {
        const rect = f.iframe.getBoundingClientRect();
        const area = Math.max(0, rect.width * rect.height);
        const visible = (f._intersectionRatio || 0) > 0.01;
        // Prefer larger visible frames.
        return (visible ? 1 : 0) * (f._intersectionRatio || 0) + Math.log10(Math.max(1, area));
      } catch (_) { return 0; }
    }

    function updateAllPolicies() {
      // Rank frames by priority score and assign full quality to top N.
      const ranked = Array.from(extraVizFrames).map(f => ({ f, score: computePriorityScore(f) }));
      ranked.sort((a, b) => b.score - a.score);
      for (let i = 0; i < ranked.length; i++) {
        const f = ranked[i].f;
        // If the parent requested precise mode, force full quality for all frames
        // so they render frequently and stay tightly in sync.
        const base = (i < MAX_FULL_QUALITY) ? { mode: 'high', fps: 60, scale: 1 } : (ranked[i].score > 0 ? { mode: 'medium', fps: 30, scale: 0.75 } : { mode: 'low', fps: 8, scale: 0.5 });
        // Always allow interpolation on children for smooth local playback.
        const policy = Object.assign({}, base, { interpolate: true });
        // attach policy for later checks
        f._policy = policy;
        sendPolicyToFrame(f, policy);
      }
    }

    function updateFramePolicy(f) {
      // Called when an individual frame's visibility/size changes — just re-evaluate all.
      try { updateAllPolicies(); } catch (_) {}
    }

    // Debounced resize handler to recompute policies when the viewport/layout changes.
    (function() {
      let _resizeTimer = null;
      window.addEventListener('resize', () => {
        try {
          if (_resizeTimer) clearTimeout(_resizeTimer);
          _resizeTimer = setTimeout(() => {
            try { updateAllPolicies(); } catch (_) {}
          }, 120);
        } catch (_) {}
      });
    })();

    function _postToFrame(frameLike, msg) {
      try {
        // support both raw iframe element and our { iframe, ready, port } objects
        // If a MessagePort is attached to the frame, use it (more efficient).
        if (frameLike?.port && typeof frameLike.port.postMessage === 'function') {
          frameLike.port.postMessage(msg);
          return true;
        }
        const win = frameLike?.contentWindow || frameLike?.iframe?.contentWindow;
        console.debug('mcbaise:postToFrame', { msg, hasWindow: !!win, hasPort: !!frameLike?.port, frameLike });
        if (!win) return false;
        // Try with PAGE_ORIGIN first; for blob/opaque frames fall back to '*'.
        try {
          win.postMessage(msg, PAGE_ORIGIN);
        } catch (e) {
          try { win.postMessage(msg, '*'); } catch (e2) { return false; }
        }
        return true;
      } catch (err) {
        console.warn('mcbaise:postToFrame error', err);
        return false;
      }
    }

    function broadcastTime(timeSec, playing) {
      if (window.__MCBAISE_DEBUG) console.debug('mcbaise:broadcastTime', { timeSec, playing, count: extraVizFrames.length });
      // Iterate a copy since we may prune dead frames.
      const nowMs = performance.now();
      // Use the configured authoritative throttle for syncs.
      const shouldSync = ((nowMs - lastSyncSentMs) >= SYNC_THROTTLE_MS);
      for (const f of Array.from(extraVizFrames)) {
        try {
          // Prefer to send through a MessagePort if available (lower overhead).
          if (f.port && typeof f.port.postMessage === 'function') {
            try {
              if (shouldSync) f.port.postMessage({ type: 'sync', timeSec, playing: !!playing, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
              else f.port.postMessage({ type: 'tick', timeSec, playing: !!playing });
              try { f._lastSeen = nowMs; } catch (_) {}
            } catch (e) { console.warn('mcbaise:port.postMessage failed', e); }
          } else {
            // fallback: only send authoritative syncs at a lower cadence via postMessage
              if (shouldSync) {
                const ok = _postToFrame(f, { type: 'sync', timeSec, playing: !!playing, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
                if (ok) try { f._lastSeen = nowMs; } catch (_) {}
                if (!ok) continue;
              }
          }
        } catch (e) {
          console.warn('mcbaise:broadcastTime:postMessage failed', e);
          // Remove problematic frame from list to avoid repeated failures.
          const idx = extraVizFrames.indexOf(f);
          if (idx !== -1) extraVizFrames.splice(idx, 1);
        }
      }
      if (shouldSync) lastSyncSentMs = nowMs;
    }

    function broadcastSync(timeSec, playing) {
      // Immediate authoritative sync to all frames (used on play/pause/seek)
      for (const f of Array.from(extraVizFrames)) {
        try {
          if (f.port && typeof f.port.postMessage === 'function') {
            try { f.port.postMessage({ type: 'sync', timeSec, playing: !!playing, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() }); } catch (e) { console.warn('mcbaise:port.postMessage failed', e); }
          } else {
            try { _postToFrame(f, { type: 'sync', timeSec, playing: !!playing, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() }); } catch (_) {}
          }
        } catch (_) {}
      }
      lastSyncSentMs = performance.now();
    }

    // Health-check: if any frame hasn't been seen by parent traffic for a while,
    // try to nudge it by sending a targeted authoritative sync. This helps
    // recover dynamically-added frames that failed to receive messages or
    // whose event loop stalled.
    try {
      setInterval(() => {
        try {
          if (!isPlaying) return;
          const now = Date.now();
          for (const f of Array.from(extraVizFrames)) {
            try {
              const last = Number(f._lastSeen || 0);
              if ((now - last) > 8000) {
                // nudge this frame
                const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
                try {
                  if (f.port && typeof f.port.postMessage === 'function') {
                    f.port.postMessage({ type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
                  } else {
                    _postToFrame(f, { type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
                  }
                } catch (_) {}
                try { f._lastSeen = Date.now(); } catch (_) {}
              }
            } catch (_) {}
          }
        } catch (_) {}
      }, 3000);
    } catch (_) {}

    // Send a short burst of authoritative syncs spaced a few ms apart to
    // reduce visible snapping when toggling precise mode on.
    function burstSync(count = 3, spacingMs = 16) {
      for (let i = 0; i < count; i++) {
        setTimeout(() => {
          try {
            const t = (player && typeof player.getCurrentTime === 'function') ? player.getCurrentTime() : 0;
            broadcastSync(t, !!isPlaying);
          } catch (_) {}
        }, i * spacingMs);
      }
    }

    function broadcastVisibility(show) {
      console.debug('mcbaise:broadcastVisibility', { show, count: extraVizFrames.length });
      for (const f of extraVizFrames) {
        _postToFrame(f, { type: 'mcbaise_set_video_visible', show: !!show });
      }
      // Also inform wasm in this page (if it exposes a handler).
      try {
        wasm?.set_video_visible?.(!!show);
      } catch (_) {}
    }

    // Set video visibility intelligently: if there are additional viz panes
    // inserted above/below the player we hide only the player contents; if
    // there are no extra viz panes we collapse the entire left column.
    function setVideoVisibility(show) {
      if (!rootEl) return;
      const leftCol = document.getElementById('left');
      const extras = leftCol ? leftCol.querySelectorAll('.extraViz') : [];
      const hasExtras = extras && extras.length > 0;

      if (show) {
        if (playerWrapEl) playerWrapEl.classList.remove('hidePlayer');
        rootEl.classList.remove('hideVideo');
      } else {
        if (hasExtras) {
          // Preserve the left column (it contains extra viz panes); hide only the player area.
          if (playerWrapEl) playerWrapEl.classList.add('hidePlayer');
          rootEl.classList.remove('hideVideo');
        } else {
          // No extras — fully collapse the left column.
          rootEl.classList.add('hideVideo');
          if (playerWrapEl) playerWrapEl.classList.remove('hidePlayer');
        }
      }

      try { broadcastVisibility(show); } catch (_) {}
    }

    // Apply visibility locally in this document (used by viz-only iframes
    // when they receive a broadcast from the parent). This updates the DOM
    // and notifies the local wasm instance if available.
    function applyLocalVideoVisibility(show) {
      try {
        if (playerWrapEl) {
          if (show) playerWrapEl.classList.remove('hidePlayer');
          else playerWrapEl.classList.add('hidePlayer');
        }
      } catch (_) {}
      try { wasm?.set_video_visible?.(!!show); } catch (_) {}
    }

    // Receive play/pause/visibility requests from child viz iframes.
    // Accept both legacy `{ mcbaise_request_playing: 'play' }` shapes and
    // the `{ type: 'mcbaise_request_playing', playing: true }` message style used by viz-only frames.
    window.addEventListener('message', (ev) => {
      console.debug('mcbaise:parent:message', { origin: ev.origin, data: ev.data });
      const d = ev.data || {};
      if (!d || typeof d !== 'object') return;

      // Child watchdog may ask for an immediate authoritative sync.
      if (d.type === 'child_watchdog_request_sync') {
        try {
          const src = ev.source;
          const f = extraVizFrames.find(x => (x.iframe && x.iframe.contentWindow) === src);
          const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
          if (f) {
            try {
              if (f.port && typeof f.port.postMessage === 'function') f.port.postMessage({ type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1) });
              else _postToFrame(f, { type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1) });
            } catch (_) {}
          } else {
            // fallback: broadcast sync to all
            broadcastSync(t, !!isPlaying);
          }
        } catch (_) {}
        return;
      }

      // Ignore child time pushes — parent is authoritative for time.
      if (d.mcbaise_time !== undefined || d.type === 'mcbaise_time') return;

      // Play/pause: support both shapes
      if (d.type === 'mcbaise_request_playing') {
        if (d.playing) player?.playVideo?.();
        else player?.pauseVideo?.();
      } else if (d.mcbaise_request_playing) {
        if (d.mcbaise_request_playing === 'play') player?.playVideo?.();
        if (d.mcbaise_request_playing === 'pause') player?.pauseVideo?.();
      }

      // Visibility: support both `{ type: 'mcbaise_set_video_visible', show }` and `{ mcbaise_set_video_visible: true }`.
      if (d.type === 'mcbaise_set_video_visible' || d.mcbaise_set_video_visible !== undefined) {
        const visible = d.type === 'mcbaise_set_video_visible' ? !!d.show : !!d.mcbaise_set_video_visible;
        setVideoVisibility(visible);
        return;
      }

      if (d.type === 'mcbaise_set_video_visible_ack') {
        console.debug('mcbaise: child acked visibility change', { applied: d.applied });
        return;
      }
    });

    // Called from Rust (wasm) to request play/pause.
    // Note: may be called before the YouTube player is ready.
    globalThis.mcbaise_request_playing = (playing) => {
      if (vizOnly) {
        // In a viz-only iframe: ask the parent to control the video.
        try {
          window.parent?.postMessage({ type: "mcbaise_request_playing", playing: !!playing }, PAGE_ORIGIN);
        } catch (_) {}
        return;
      }

      const want = !!playing;
      pendingPlayingRequest = want;

      if (!playerReady || !player) return;
      try {
        if (want) player.playVideo?.();
        else player.pauseVideo?.();
      } catch (e) {
        console.warn('mcbaise_request_playing failed', e);
      }
    };

    function startLoop() {
      if (rafId) return;
      const loop = () => {
        rafId = requestAnimationFrame(loop);
        try {
          const t0 = performance.now();
          if (!playerReady || !player?.getCurrentTime) return;
          const nowMs = performance.now();
          if (nowMs - lastBroadcastMs < BROADCAST_THROTTLE_MS) return;
          lastBroadcastMs = nowMs;
          const t = player.getCurrentTime();

          // Time sub-steps so we can tell whether wasm.set_video_time or
          // broadcastTime/postMessage is responsible for long rAFs.
          const stepStart = performance.now();
          let afterSetVideo = stepStart;
          if (typeof wasm?.set_video_time === 'function') {
            // Schedule the wasm call asynchronously to avoid blocking the rAF.
            try { scheduleWasmSetVideoTime(t, !!isPlaying); } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:parent:schedule:error', e); }
            afterSetVideo = performance.now();
          } else {
            // no wasm yet; mark afterSetVideo equal to start so durations reflect only broadcast
            afterSetVideo = performance.now();
          }

          const beforeBroadcast = performance.now();
          try { broadcastTime(t, !!isPlaying); } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:parent:broadcastTime:error', e); }
          const afterBroadcast = performance.now();

          const dur_set = Math.round((afterSetVideo - stepStart));
          const dur_broadcast = Math.round((afterBroadcast - beforeBroadcast));
          const total = Math.round(afterBroadcast - t0);
          if (window.__MCBAISE_DEBUG && total > 50) console.warn('mcbaise:parent:rAF:work', { total: total + 'ms', set_video_time_ms: dur_set + 'ms', broadcast_ms: dur_broadcast + 'ms' });
        } catch (e) {
          if (window.__MCBAISE_DEBUG) console.error('mcbaise:parent:rAF:error', e);
        }
      };
      loop();
    }

    function stopLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function startPoll() {
      if (pollId) return;
      pollId = setInterval(() => {
        if (!playerReady || !player?.getCurrentTime) return;
        const t = player.getCurrentTime();
        // Use the scheduler to avoid synchronous wasm blocking inside the interval tick.
          try { scheduleWasmSetVideoTime(t, !!isPlaying); } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:poll:schedule:error', e); }
          broadcastTime(t, !!isPlaying);
        }, 100);
    }

    function stopPoll() {
      if (pollId) clearInterval(pollId);
      pollId = null;
    }

    window.onYouTubeIframeAPIReady = () => {
      ytReady = false;
      setYoutubeLoading(true, "Preparing the player…");
      refreshLoading();
      player = new YT.Player("player", {
        videoId: VIDEO_ID,
        width: "100%",
        height: "100%",
        playerVars: {
          autoplay: 0,
          controls: 1,
          rel: 0,
          modestbranding: 1,
          playsinline: 1,
          enablejsapi: 1,
          // Required on some browsers/devices to avoid postMessage origin mismatch.
          origin: PAGE_ORIGIN,
        },
        events: {
          onReady: () => {
            playerReady = true;
            ytReady = true;
            setYoutubeLoading(false, "");
            refreshLoading();
            const t = player.getCurrentTime?.() ?? 0;
            wasm?.set_video_time?.(t, false);
            try { broadcastSync(t, false); } catch (_) { broadcastTime(t, false); }

            if (pendingPlayingRequest !== null) {
              try {
                if (pendingPlayingRequest) player.playVideo?.();
                else player.pauseVideo?.();
              } catch (e) {
                console.warn('mcbaise_request_playing (deferred) failed', e);
              }
            }
          },
          onStateChange: (e) => {
            if (e.data === YT.PlayerState.PLAYING) {
              isPlaying = true;
              startLoop();
              startPoll();
                // immediate authoritative sync when playback starts
                try { const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0; broadcastSync(t, true); } catch (_) {}
            } else {
              isPlaying = false;
              const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
              wasm?.set_video_time?.(t, false);
                // authoritative sync on pause/stop
                try { broadcastSync(t, false); } catch (_) {}
              stopLoop();
              stopPoll();
            }
          },
          onPlaybackRateChange: () => {
            // Keep wasm time/playing fresh when playback rate changes.
            const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
            wasm?.set_video_time?.(t, !!isPlaying);
              try { broadcastSync(t, !!isPlaying); } catch (_) {}
          },
          onError: (err) => {
            console.warn('YouTube player error', err);
            const t = playerReady ? (player.getCurrentTime?.() ?? 0) : 0;
            wasm?.set_video_time?.(t, false);
              try { broadcastSync(t, false); } catch (_) {}
            stopLoop();
            stopPoll();
          }
        }
      });
    };

    // In viz-only mode, receive time/visibility/playback updates from the parent page.
    // Support both window.postMessage and an attached MessagePort (preferred).
    (function() {
      let childPort = null;
      let childLoopId = null;
      let lastSync = { timeSec: 0, tsMs: 0, playing: false, rate: 1 };
      // childPolicy controls local throttling and smoothing behavior. Default
      // includes `interpolate: true` so children smooth between authoritative
      // sync samples by default.
      let childPolicy = { mode: 'high', fps: 60, scale: 1, interpolate: true };
      let _lastAppliedMs = 0;

      function applyPolicy(policy) {
        try {
          childPolicy = Object.assign({}, childPolicy, policy || {});
          // If wasm exposes a render scale API, call it; otherwise we prefer to only throttle time updates.
          try {
            console.debug('mcbaise:child:applyPolicy', childPolicy);
            // Prefer calling the wasm export `set_render_scale(scale)` if available.
            // In many cases the wasm module may not yet be initialized when the
            // first policy arrives; attempt a few short retries rather than
            // failing silently so devs can toggle scale from the parent early.
            function ensureRenderScale(scale, attemptsLeft = 6) {
              try {
                if (typeof wasm?.set_render_scale === 'function') {
                  try { wasm.set_render_scale(scale); return true; } catch (e) { if (window.__MCBAISE_DEBUG) console.warn('mcbaise:child:set_render_scale:call_failed', e); }
                }
              } catch (_) {}
              if (attemptsLeft <= 0) {
                if (window.__MCBAISE_DEBUG) console.debug('mcbaise:child:applyPolicy - no wasm.set_render_scale after retries, skipping JS canvas resize');
                return false;
              }
              // Retry after a short delay — keeps retry lightweight and bounded.
              setTimeout(() => ensureRenderScale(scale, attemptsLeft - 1), 200);
              return false;
            }
            ensureRenderScale(childPolicy.scale);
          } catch (_) {}
        } catch (_) {}
      }

      // Recompute canvas/application sizing when the viewport or canvas element resizes.
      try {
        let _childResizeTimer = null;
        window.addEventListener('resize', () => {
          try {
            if (_childResizeTimer) clearTimeout(_childResizeTimer);
            _childResizeTimer = setTimeout(() => {
              try { applyPolicy(childPolicy); } catch (_) {}
            }, 120);
          } catch (_) {}
        });

        // Also observe the canvas element for size changes so we can reapply or restore scale.
        try {
          const c = document.getElementById('bevy-canvas');
          if (c && typeof ResizeObserver !== 'undefined') {
            const ro = new ResizeObserver(() => {
              try {
                if (_childResizeTimer) clearTimeout(_childResizeTimer);
                _childResizeTimer = setTimeout(() => { try { applyPolicy(childPolicy); } catch (_) {} }, 80);
              } catch (_) {}
            });
            try { ro.observe(c); } catch (_) {}
          }
        } catch (_) {}
      } catch (_) {}

      // Correction state used to smoothly converge to authoritative time
      // without visible jumps. `correctionVel` is seconds-per-second to add
      // to the nominal playback rate for a short convergence window.
      let _correctionVel = 0;
      let _correctionUntil = 0;

      function startChildLoop() {
        if (childLoopId) return;
        const step = () => {
            childLoopId = requestAnimationFrame(step);
            try {
              const t0 = performance.now();
              const now = performance.now();
              let t = Number(lastSync.timeSec) || 0;
            // If interpolation is enabled, locally integrate time forward from
            // the last authoritative sync. If disabled, remain perfectly
            // authoritative by using the last sync time directly.
            if (childPolicy.interpolate && lastSync.playing) {
              const dt = (now - (lastSync.tsMs || now)) / 1000;
              // If we have an active correction velocity, blend it in and
              // reduce it over time until the correction window expires.
              let vel = Number(lastSync.rate || 1);
              if (_correctionUntil > now) {
                vel += _correctionVel;
              }
              t = t + dt * vel;
            } else {
              // stay exactly at authoritative time (no local extrapolation)
              t = Number(lastSync.timeSec) || 0;
            }
            // Throttle actual wasm updates according to policy.fps
            const minInterval = 1000 / (childPolicy.fps || 60);
            if ((now - _lastAppliedMs) >= minInterval) {
              const subStart = performance.now();
              let afterSet = subStart;
                if (typeof wasm?.set_video_time === 'function') {
                  try { scheduleWasmSetVideoTime(t, !!lastSync.playing); } catch (e) { if (window.__MCBAISE_DEBUG) console.error('mcbaise:child:schedule:error', e); }
                  afterSet = performance.now();
                } else {
                  afterSet = performance.now();
                }
              _lastAppliedMs = now;
              const dur_total = Math.round(performance.now() - t0);
              const dur_set = Math.round(afterSet - subStart);
              if (window.__MCBAISE_DEBUG && dur_total > 50) console.warn('mcbaise:child:rAF:work', { total: dur_total + 'ms', set_video_time_ms: dur_set + 'ms' });
            }
          } catch (_) {}
        };
        step();
      }

      function stopChildLoop() {
        if (!childLoopId) return;
        cancelAnimationFrame(childLoopId);
        childLoopId = null;
      }

      // child-side clock offset (ms) applied to parent timestamps: parent_ts + offset -> child clock
      let childClockOffsetMs = 0;

      function applySync(timeSec, playing, rate, parent_ts_ms) {
        // Authoritative sync from parent. We implement latency compensation
        // and a smooth phase-correction to reduce visible jumps while being
        // more accurate than naive interpolation.
        const nowPerf = performance.now();
        const nowWall = Date.now();

        // Predict current local playback time based on previous authoritative
        // sample (if any) and local integration.
        let predictedLocal = Number(lastSync.timeSec || 0);
        if (childPolicy.interpolate && lastSync.playing) {
          const prevTs = Number(lastSync.tsMs || nowPerf);
          const dt = (nowPerf - prevTs) / 1000;
          predictedLocal = predictedLocal + dt * (Number(lastSync.rate || 1) + (_correctionUntil > nowPerf ? _correctionVel : 0));
        }

        // Estimate one-way transport delay using parent_ts_ms corrected by any measured clock offset.
        let transportMs = 0;
        try {
          const parentTs = Number(parent_ts_ms || nowWall);
          const adjustedParentWall = parentTs + (childClockOffsetMs || 0);
          transportMs = Math.max(0, nowWall - adjustedParentWall);
        } catch (_) { transportMs = 0; }

        // Compute adjusted authoritative time by accounting for transport delay.
        const adjustedAuthoritative = Number(timeSec || 0) + (transportMs / 1000) * (Number(rate || 1));

        // Error between authoritative and our predicted local time.
        const err = adjustedAuthoritative - predictedLocal;

        // Decide snap vs. smooth correction. If error is large, snap immediately.
        const SNAP_THRESHOLD = 0.25; // seconds
        const CONVERGENCE_MS = 300; // convergence window for phase correction (ms)

        lastSync.timeSec = Number(timeSec) || 0;
        lastSync.tsMs = nowPerf;
        lastSync.playing = !!playing;
        lastSync.rate = Number(rate) || 1;

          if (Math.abs(err) > SNAP_THRESHOLD) {
          // Large error — snap to adjusted authoritative time to avoid long drift.
          try { requestAnimationFrame(() => { try { wasm?.set_video_time?.(adjustedAuthoritative, lastSync.playing); } catch (_) {} }); } catch (_) {}
          // clear any small corrections
          _correctionVel = 0;
          _correctionUntil = 0;
        } else {
          // Small error — apply temporary correction velocity to converge smoothly.
          // We compute a velocity (seconds/sec) that will remove `err` over CONVERGENCE_MS.
          const convergenceSec = Math.max(0.05, CONVERGENCE_MS / 1000);
          _correctionVel = err / convergenceSec; // this will be added to playback rate
          // clamp correction to reasonable bounds to avoid crazy speeds
          const MAX_CORRECTION = 1.0; // allow up to +1s/s additional speed
          if (_correctionVel > MAX_CORRECTION) _correctionVel = MAX_CORRECTION;
          if (_correctionVel < -MAX_CORRECTION) _correctionVel = -MAX_CORRECTION;
          _correctionUntil = nowPerf + CONVERGENCE_MS;
          // Apply an immediate small adjust to be responsive (but not a snap)
          try { requestAnimationFrame(() => { try { wasm?.set_video_time?.(predictedLocal, lastSync.playing); } catch (_) {} }); } catch (_) {}
        }

        if (lastSync.playing) startChildLoop(); else stopChildLoop();
      }

      function handleChildMessage(data, origin) {
        if (!data || typeof data !== 'object') return;
        // Accept both legacy and new message shapes. Treat both as authoritative sync.
        if (data.type === 'sync' || data.type === 'mcbaise_time') {
          applySync(data.timeSec, data.playing, data.rate);
          return;
        }
        if (data.type === 'policy') {
          try { applyPolicy(data.policy); } catch (_) {}
          return;
        }
        // Respond to ping messages from the parent for clock/Round-Trip Time estimation.
        if (data.type === 'ping') {
          try {
            const t_child_recv_ms = Date.now();
            // Reply on the same port to the parent with the timestamp we received it.
            try { childPort.postMessage({ type: 'pong', id: data.id, t_parent_send_ms: data.t_parent_send_ms, t_child_recv_ms }); } catch (_) {}
          } catch (_) {}
          return;
        }
        // Parent may send a computed clock offset to the child to apply.
        if (data.type === 'clock_offset') {
          try { childClockOffsetMs = Number(data.offset_ms) || 0; } catch (_) { childClockOffsetMs = 0; }
          console.debug('mcbaise:child:clock_offset', childClockOffsetMs);
          return;
        }
        // Lightweight 'tick' messages are advisory; ignore for now to avoid thrash.
        if (data.type === 'tick') {
          return;
        }
        if (data.type === 'mcbaise_set_video_visible') {
          try { applyLocalVideoVisibility?.(!!data.show); } catch (_) {}
          try { window.parent?.postMessage({ type: 'mcbaise_set_video_visible_ack', applied: !!data.show }, PAGE_ORIGIN); } catch (_) {}
          return;
        }
        if (data.type === 'mcbaise_request_playing') {
          try {
            if (data.playing) wasm?.request_playing?.(true);
            else wasm?.request_playing?.(false);
          } catch (_) {}
          return;
        }
      }

      window.addEventListener('message', (e) => {
        // Special-case: attach a transferred MessagePort regardless of origin.
        if (e.data && e.data.type === 'attachPort' && e.ports && e.ports[0]) {
          childPort = e.ports[0];
          try {
            childPort.onmessage = (ev) => handleChildMessage(ev.data);
            childPort.start?.();
          } catch (_) {}
          return;
        }

        // For other messages, perform origin check as before.
        if (e.origin !== PAGE_ORIGIN) {
          console.debug('mcbaise:child:ignored-origin', { origin: e.origin, expected: PAGE_ORIGIN, data: e.data });
          return;
        }
        console.debug('mcbaise:child:message', e.data);
        handleChildMessage(e.data, e.origin);
      });

      // Watchdog: if the child is supposed to be playing but the rAF loop isn't active,
      // try to (re)start it occasionally — this helps recover from cases where the
      // loop was paused by the UA and didn't resume.
      try {
        setInterval(() => {
          try {
            const now = performance.now();
            const age = now - (lastSync.tsMs || 0);
            if (lastSync.playing) {
              if (!childLoopId) {
                // If we've not received an authoritative sync for a while, nudge the parent.
                if (age > 5000) {
                  try {
                    // Prefer MessagePort if attached, otherwise fallback to window.postMessage
                    if (childPort && typeof childPort.postMessage === 'function') {
                      try { childPort.postMessage({ type: 'child_watchdog_request_sync' }); } catch (_) {}
                    } else {
                      try { window.parent?.postMessage({ type: 'child_watchdog_request_sync' }, PAGE_ORIGIN); } catch (_) {}
                    }
                  } catch (_) {}
                }
                startChildLoop();
              }
            } else {
              // if not playing, ensure loop is stopped
              if (childLoopId) stopChildLoop();
            }
          } catch (_) {}
        }, 1000);
      } catch (_) {}
    })();

    function injectExtraViz(direction) {
      if (vizOnly) return;
      direction = direction || 'right';
      // Keep it simple: only inject one extra viz per click.
      const pane = document.createElement('div');
      pane.className = 'extraViz';

      const iframe = document.createElement('iframe');
      iframe.loading = 'lazy';
      iframe.title = 'mcbaise viz';
      const u = new URL(window.location.href);
      u.searchParams.set('vizOnly', '1');
      iframe.src = u.toString();
      pane.appendChild(iframe);

      const left = document.getElementById('left');
      const playerWrap = document.getElementById('playerWrap');
      const right = document.getElementById('right');

      const isPortrait = window.matchMedia('(max-aspect-ratio: 1/1)').matches;
      if (isPortrait && (direction === 'left' || direction === 'right')) {
        // Place pane into persistent side slot so cardinal placement is preserved.
        const leftSlot = document.getElementById('sideLeftSlot');
        const rightSlot = document.getElementById('sideRightSlot');
        const slot = direction === 'left' ? leftSlot : rightSlot;
        if (slot) {
          pane.dataset.placedIn = 'sideSlot';
          pane.dataset.side = direction;
          slot.appendChild(pane);
          // Defer class additions to avoid layout thrash.
          try {
            scheduleWrite(() => {
              slot.classList.add('hasPane');
              try { rootEl.classList.add('hasPortraitExtras'); } catch (_) {}
              try { void slot.offsetHeight; } catch (_) {}
              requestAnimationFrame(() => { try { window.dispatchEvent(new Event('resize')); } catch (_) {} });
            });
          } catch (_) {
            slot.classList.add('hasPane');
            try { rootEl.classList.add('hasPortraitExtras'); } catch (_) {}
          }
        } else {
          // fallback to DOM insertion
          if (direction === 'left' && left) rootEl.insertBefore(pane, left);
          else if (direction === 'right' && right) rootEl.insertBefore(pane, right);
          else (right || left || rootEl).appendChild(pane);
        }
      } else {
        // Deterministic placement by direction (desktop / landscape behavior)
        if (direction === 'left' && left) {
          rootEl.insertBefore(pane, left);
        } else if (direction === 'right' && right) {
          rootEl.insertBefore(pane, right);
        } else if ((direction === 'top' || direction === 'above') && left && playerWrap) {
          left.insertBefore(pane, playerWrap);
        } else if ((direction === 'bottom' || direction === 'below') && left && playerWrap) {
          left.appendChild(pane);
        } else {
          // fallback: append to right
          (right || left || rootEl).appendChild(pane);
        }
      }

      // Track frame with readiness flag and send initial messages on load.
        const frameObj = { iframe, ready: false, port: null };
        // Create a MessageChannel for this frame; we'll transfer port2 to child on load.
        try {
          const mc = new MessageChannel();
          frameObj._localPort = mc.port1; // parent-side port
          frameObj._transferPort = mc.port2; // to be transferred to child
        } catch (_) {
          frameObj._localPort = null;
          frameObj._transferPort = null;
        }
        extraVizFrames.push(frameObj);
        // Start observing this iframe for visibility/size-based priority decisions.
        try { if (io && iframe) io.observe(iframe); } catch (_) {}
        try { updateAllPolicies(); } catch (_) {}
        // Ensure the main RAF loop is running if the player is playing.
        try { if (isPlaying) startLoop(); } catch (_) {}
        iframe.addEventListener('load', () => {
          frameObj.ready = true;
          // Transfer MessagePort to child if available
          try {
            if (frameObj._transferPort && iframe.contentWindow) {
              try {
                iframe.contentWindow.postMessage({ type: 'attachPort' }, PAGE_ORIGIN, [frameObj._transferPort]);
              } catch (e) {
                try { iframe.contentWindow.postMessage({ type: 'attachPort' }, '*', [frameObj._transferPort]); } catch (_) {}
              }
              // start listening on parent-side port
              try {
                    frameObj._localPort.start?.();
                    frameObj.port = frameObj._localPort;
                    // Set up a simple ping/pong handshake to measure RTT and clock offset
                    // so the child can correct for transport latency and any clock skew.
                    frameObj.port.onmessage = (ev) => {
                      try {
                        const d = ev.data || {};
                        if (d.type === 'pong' && typeof d.t_parent_send_ms !== 'undefined') {
                          // Compute RTT and clock offset estimate (child_time - parent_time_at_midpoint)
                          const rtt = Date.now() - Number(d.t_parent_send_ms || Date.now());
                          const offset = Number(d.t_child_recv_ms || 0) - (Number(d.t_parent_send_ms || 0) + rtt / 2);
                          frameObj._clockOffsetMs = offset;
                          // Send the computed offset to the child so it can correct locally.
                          try { frameObj.port.postMessage({ type: 'clock_offset', offset_ms: offset }); } catch (_) {}
                          console.debug('mcbaise:ping', { rtt, offset, frame: frameObj });
                        } else {
                          // child -> parent messages on the port if needed
                          console.debug('mcbaise:port:message', ev.data);
                        }
                      } catch (e) { console.debug('mcbaise:port:onmessage:error', e); }
                    };
                    // Send an immediate ping and then periodically refresh the estimate.
                    const sendPing = () => {
                      try {
                        const id = Math.random().toString(36).slice(2);
                        const t_parent_send_ms = Date.now();
                        frameObj._lastPingId = id;
                        frameObj._lastPingSentMs = t_parent_send_ms;
                        try { frameObj.port.postMessage({ type: 'ping', id, t_parent_send_ms }); } catch (_) {}
                      } catch (_) {}
                    };
                    // initial ping
                    sendPing();
                    try { frameObj._pingInterval = setInterval(sendPing, 5000); } catch (_) {}
                  } catch (_) {}
            }
          } catch (_) {}
          // Send an initial time and visibility sample after load.
          try {
            const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
            // Prefer port-based delivery, fallback to postMessage
              if (frameObj.port && typeof frameObj.port.postMessage === 'function') {
                  frameObj.port.postMessage({ type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
                  try { frameObj._lastSeen = Date.now(); } catch (_) {}
              frameObj.port.postMessage({ type: 'mcbaise_set_video_visible', show: !(playerWrapEl && playerWrapEl.classList.contains('hidePlayer')) });
            } else {
                  _postToFrame(frameObj, { type: 'sync', timeSec: t, playing: !!isPlaying, rate: (player?.getPlaybackRate?.() ?? 1), parent_ts_ms: Date.now() });
                  try { frameObj._lastSeen = Date.now(); } catch (_) {}
              _postToFrame(frameObj, { type: 'mcbaise_set_video_visible', show: !(playerWrapEl && playerWrapEl.classList.contains('hidePlayer')) });
            }
          } catch (_) {}
        });

      // Push an initial time sample as soon as possible to already-loaded frames.
      const t = playerReady ? (player?.getCurrentTime?.() ?? 0) : 0;
      try { broadcastSync(t, !!isPlaying); } catch (_) { broadcastTime(t, !!isPlaying); }
    }


    async function main() {
      try {
        await bootWasm();
      } catch (err) {
        console.error(err);
        bootFailed = true;
        refreshLoading();
        throw err;
      }
      if (vizOnly) {
        // Viz-only iframe: no YouTube; parent will drive time via postMessage.
        ytReady = true;
        setYoutubeLoading(false, "");
        refreshLoading();
        if (videoPiContainer) videoPiContainer.style.display = "none";
        return;
      }

      // DOM controls were removed; the wasm app uses an egui overlay for runtime controls.
      setYoutubeLoading(true, "Loading YouTube…");
      await loadScript("https://www.youtube.com/iframe_api");
    }

    // Parent-level precise UI removed: children always interpolate locally.

    // Wire up directional pi buttons to inject viz in that cardinal direction.
    if (videoPiContainer) {
      const btns = videoPiContainer.querySelectorAll('.videoPi');
      btns.forEach(b => {
        b.addEventListener('click', (ev) => {
          const dir = b.dataset.dir || 'right';
          injectExtraViz(dir);
        });
      });
    }

    main().catch(err => console.error(err));
  </script>
</body>
</html>
